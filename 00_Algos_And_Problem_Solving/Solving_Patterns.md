Some solving patterns are:

- Frequency Counter
- Multiple Pointers
- Sliding Window
- Divide and Counquer
- Dynamic Programming
- Greedy Algorithms
- Backtracking
- many more...

# Frequency Counter

This patttern uses objects or sets to collect values/frequencies of values. This can often avoid the need for nested loops or O(N^2) operations with array / strings. Usually it takes O(N) time.

# Multiple Pointes

Creating pointers or values that correspond to an index or position and move towards the beginning, end or middle based on a certain condition. Very efficient for solving problems with minimal space complexity as well.

# Sliding Window

This pattern involves creating a window which can either be an array or number from one position to another.
Depending on a certain condiition, the window either iincreases or closes(and a new windoww is created).

Very useful for keeping track of a subset of data in an array/string etc.

# Divide and Conquer

This pattern involves divding a data set into smaller chunks and then repearing the process with a subset of data. This pattern can tremendously decrease time complexity. It is great for implementing searching on a SORTED array. As you pick middle and absolutely sure that left part is less than middle value and right part is more that middle.
